TT les codes
Archer.cs 
namespace RattrapageProjet.Models
{
    public class Archer : Trainable
    {
        public Archer(int x, int y) : base(x, y, 10) { }
    }
} 
Barbarian.cs
namespace RattrapageProjet.Models
{
    public class Barbarian : Trainable
    {
        public Barbarian(int x, int y) : base(x, y, 15) { }
    }
} 
Barrack.cs
namespace RattrapageProjet.Models
{
    public class Barrack : Building
    {
        public Barrack(int x, int y) : base(x, y, 30, "Barrack")
        {
        }

        public override void OnInteract()
        {
        }
    }
} 
Board.cs
using System.Collections.Generic;

namespace RattrapageProjet.Models
{
    public class Board
    {
        public List<Building> Buildings { get; set; }
        public Player Player { get; set; }
        public List<Trainable> Troops { get; set; }
        public List<Enemy> Enemies { get; set; }

        private int raiderSpawnCounter = 0;
        private int raiderSpawnInterval = 10;
        private int bombermanSpawnCounter = 0;
        private int bombermanSpawnInterval = 20;
        private int raiderSpawnCount = 1;
        private int bombermanSpawnCount = 1;
        private int turnsElapsed = 0;

        public Board()
        {
            Buildings = new List<Building>();
            Player = new Player(0, 0);
            Troops = new List<Trainable>();
            Enemies = new List<Enemy>();
            Buildings.Add(new TownHall(5, 5));
        }

        public void AddBuilding(Building building)
        {
            Buildings.Add(building);
        }

        public void AddTroop(Trainable troop)
        {
            Troops.Add(troop);
        }

        public void AddEnemy(Enemy enemy)
        {
            Enemies.Add(enemy);
        }

        public bool BuildBuilding(string buildingType)
        {
            int x = Player.X;
            int y = Player.Y;
            Building building = null;
            int cost = 0;
            switch (buildingType)
            {
                case "GoldMine":
                    cost = BuildingCosts.GoldMine;
                    if (Player.Gold >= cost)
                    {
                        building = new GoldMine(x, y);
                        Player.Gold -= cost;
                    }
                    break;
                case "ElixirCollector":
                    cost = BuildingCosts.ElixirCollector;
                    if (Player.Gold >= cost)
                    {
                        building = new ElixirCollector(x, y);
                        Player.Gold -= cost;
                    }
                    break;
                case "Wall":
                    cost = BuildingCosts.Wall;
                    if (Player.Gold >= cost)
                    {
                        building = new Wall(x, y);
                        Player.Gold -= cost;
                    }
                    break;
                case "Barrack":
                    cost = BuildingCosts.Barrack;
                    if (Player.Gold >= cost)
                    {
                        building = new Barrack(x, y);
                        Player.Gold -= cost;
                    }
                    break;
            }
            if (building != null)
            {
                Buildings.Add(building);
                return true;
            }
            return false;
        }

        public bool CollectResource()
        {
            foreach (var building in Buildings)
            {
                if (building.X == Player.X && building.Y == Player.Y)
                {
                    if (building is GoldMine goldMine)
                    {
                        Player.CollectGold(goldMine.GenerateResource());
                        return true;
                    }
                    if (building is ElixirCollector elixirCollector)
                    {
                        Player.CollectElixir(elixirCollector.GenerateResource());
                        return true;
                    }
                }
            }
            return false;
        }

        public Building GetClosestBuilding(int x, int y)
        {
            Building closest = null;
            double minDist = double.MaxValue;
            foreach (var building in Buildings)
            {
                double dist = (building.X - x) * (building.X - x) + (building.Y - y) * (building.Y - y);
                if (dist < minDist)
                {
                    minDist = dist;
                    closest = building;
                }
            }
            return closest;
        }

        public void EnemyActions()
        {
            foreach (var enemy in Enemies)
            {
                Building target = GetClosestBuilding(enemy.X, enemy.Y);
                if (target != null)
                {
                    if (enemy.X == target.X && enemy.Y == target.Y)
                    {
                        enemy.Attack(target);
                    }
                    else
                    {
                        enemy.MoveTowards(target.X, target.Y);
                    }
                }
            }
        }

        public bool UpdateBuildingsAndCheckDefeat()
        {
            foreach (var building in Buildings)
            {
                if (building is TownHall && building.Health <= 0)
                {
                    return true;
                }
            }
            Buildings.RemoveAll(b => b.Health <= 0);
            return false;
        }

        public void SpawnRaider(int x, int y)
        {
            Enemies.Add(new Raider(x, y));
        }

        public void RaiderAutoSpawn(int spawnX, int spawnY)
        {
            raiderSpawnCounter++;
            turnsElapsed++;
            if (raiderSpawnCounter >= raiderSpawnInterval)
            {
                for (int i = 0; i < raiderSpawnCount; i++)
                    SpawnRaider(spawnX, spawnY);
                raiderSpawnCounter = 0;
            }
            if (turnsElapsed % 25 == 0 && raiderSpawnCount < 5)
                raiderSpawnCount++;
        }

        public bool TrainTroop(string troopType)
        {
            foreach (var building in Buildings)
            {
                if (building is Barrack && building.X == Player.X && building.Y == Player.Y)
                {
                    if (troopType == "Archer" && Player.Elixir >= TroopCosts.Archer)
                    {
                        Troops.Add(new Archer(building.X, building.Y));
                        Player.Elixir -= TroopCosts.Archer;
                        return true;
                    }
                    if (troopType == "Barbarian" && Player.Elixir >= TroopCosts.Barbarian)
                    {
                        Troops.Add(new Barbarian(building.X, building.Y));
                        Player.Elixir -= TroopCosts.Barbarian;
                        return true;
                    }
                }
            }
            return false;
        }

        // Dans Board.cs - m√©thode TroopActions()
        public void TroopActions()
        {
            var townHall = Buildings.FirstOrDefault(b => b is TownHall);
            
            foreach (var troop in Troops)
            {
                Enemy closest = GetClosestEnemy(troop);
                
                if (closest != null)
                {
                    if (troop.X == closest.X && troop.Y == closest.Y)
                    {
                        troop.Attack(closest);
                    }
                    else
                    {
                        troop.MoveTowards(closest.X, closest.Y);
                    }
                }
                else if (townHall != null)
                {
                    // Retourner au Town Hall si pas d'ennemi
                    if (troop.X != townHall.X || troop.Y != townHall.Y)
                    {
                        troop.MoveTowards(townHall.X, townHall.Y);
                    }
                }
            }
        }
        public void BombermanAutoSpawn(int spawnX, int spawnY)
        {
            bombermanSpawnCounter++;
            if (bombermanSpawnCounter >= bombermanSpawnInterval)
            {
                for (int i = 0; i < bombermanSpawnCount; i++)
                    SpawnBomberman(spawnX, spawnY);
                bombermanSpawnCounter = 0;
            }
            if (turnsElapsed % 50 == 0 && bombermanSpawnCount < 3)
                bombermanSpawnCount++;
        }

        public void SpawnBomberman(int x, int y)
        {
            Enemies.Add(new Bomberman(x, y));
        }
        // Dans Board.cs
        public bool IsPositionOccupied(int x, int y)
        {
            return Buildings.Any(b => b.X == x && b.Y == y) || 
                Troops.Any(t => t.X == x && t.Y == y) || 
                Enemies.Any(e => e.X == x && e.Y == y);
        }
        public void CleanupDeadEntities()
        {
            Enemies.RemoveAll(e => e.Health <= 0);
            Troops.RemoveAll(t => t.Health <= 0);
        }
    }

} 
Bomberman.cs
namespace RattrapageProjet.Models
{
    public class Bomberman : Enemy
    {
        public Bomberman(int x, int y) : base(x, y, 1) { }
        // Dans Bomberman.cs
        public List<(int x, int y)> FindPathToTownHall(Board board)
        {
            var townHall = board.Buildings.FirstOrDefault(b => b is TownHall);
            if (townHall == null) return new List<(int, int)>();
            
            // Impl√©mentation simple BFS pour le pathfinding
            // (vous pouvez impl√©menter A* pour plus d'efficacit√©)
            return BreadthFirstSearch(X, Y, townHall.X, townHall.Y, board);
        }
        public override void Attack(Building target)
        {
            if (target is TownHall)
            {
                target.Health = 0;
                Console.WriteLine("üí• Le Bomberman explose et d√©truit instantan√©ment le Town Hall ! üí•");
            }
            else
            {
                base.Attack(target);
            }
        }
    }
}
Building.cs
namespace RattrapageProjet.Models
{
    public abstract class Building
    {
        public int X { get; set; }
        public int Y { get; set; }
        public int Health { get; set; }
        public string Name { get; set; }

        public Building(int x, int y, int health, string name)
        {
            X = x;
            Y = y;
            Health = health;
            Name = name;
        }

        public abstract void OnInteract();
    }
} 
BuildingCosts.cs
namespace RattrapageProjet.Models
{
    public static class BuildingCosts
    {
        public const int GoldMine = 50;
        public const int ElixirCollector = 50;
        public const int Wall = 10;
        public const int Barrack = 100;
    }
} 
ElixirCollector.cs
namespace RattrapageProjet.Models
{
    public class ElixirCollector : ResourceGenerator
    {
        public ElixirCollector(int x, int y) : base(x, y, 15, "ElixirCollector", 10)
        {
        }

        public override int GenerateResource()
        {
            return ResourcePerTurn;
        }

        public override void OnInteract()
        {
    
        }
    }
} 
Enemy.cs
namespace RattrapageProjet.Models
{
    public abstract class Enemy : Npc
    {
        public Enemy(int x, int y, int health) : base(x, y, health) { }

        public virtual void Attack(Building target)
        {
            if (target != null)
            {
                target.Health -= 5;
                if (target.Health < 0)
                    target.Health = 0;
            }
        }

        public void MoveTowards(int targetX, int targetY)
        {
            int dx = targetX - X;
            int dy = targetY - Y;
            if (dx != 0)
                X += dx / System.Math.Abs(dx);
            else if (dy != 0)
                Y += dy / System.Math.Abs(dy);
        }
    }
} 
Entity.cs
namespace RattrapageProjet.Models
{
    public abstract class Entity
    {
        public int X { get; set; }
        public int Y { get; set; }
        public int Health { get; set; }

        public Entity(int x, int y, int health)
        {
            X = x;
            Y = y;
            Health = health;
        }

        // Dans Entity.cs
        public void Move(int dx, int dy)
        {
            int newX = X + dx;
            int newY = Y + dy;
            
            // V√©rifier les limites (0-14)
            if (newX >= 0 && newX < 15 && newY >= 0 && newY < 15)
            {
                X = newX;
                Y = newY;
            }
        }
    }
} 
GoldMine.cs
namespace RattrapageProjet.Models
{
    public class GoldMine : ResourceGenerator
    {
        public GoldMine(int x, int y) : base(x, y, 15, "GoldMine", 10)
        {
        }

        public override int GenerateResource()
        {
            return ResourcePerTurn;
        }

        public override void OnInteract()
        {

        }
    }
} 
Npc.cs
namespace RattrapageProjet.Models
{
    public abstract class Npc : Entity
    {
        public Npc(int x, int y, int health) : base(x, y, health) { }
    }
} 
Player.cs
namespace RattrapageProjet.Models
{
    public class Player : Entity
    {
        public int Gold { get; set; }
        public int Elixir { get; set; }

        public Player(int x, int y) : base(x, y, 20)
        {
            Gold = 0;
            Elixir = 0;
        }

        public void CollectGold(int amount)
        {
            Gold += amount;
        }

        public void CollectElixir(int amount)
        {
            Elixir += amount;
        }
    }
} 
Raider.cs
namespace RattrapageProjet.Models
{
    public class Raider : Enemy
    {
        public Raider(int x, int y) : base(x, y, 12) { }
    }
} 
ResourceGenerator.cs
namespace RattrapageProjet.Models
{
    public abstract class ResourceGenerator : Building
    {
        public int ResourcePerTurn { get; set; }
        public ResourceGenerator(int x, int y, int health, string name, int resourcePerTurn)
            : base(x, y, health, name)
        {
            ResourcePerTurn = resourcePerTurn;
        }

        public abstract int GenerateResource();
    }
} 
TownHall.cs

namespace RattrapageProjet.Models
{
    public class TownHall : Building
    {
        public TownHall(int x, int y) : base(x, y, 50, "TownHall")
        {
        }

        public override void OnInteract()
        {
        }
    }
} 
Trainable.cs
namespace RattrapageProjet.Models
{
    public abstract class Trainable : Npc
    {
        public Trainable(int x, int y, int health) : base(x, y, health) { }

        public void Attack(Enemy target)
        {
            if (target != null)
            {
                target.Health -= 5;
                if (target.Health < 0)
                    target.Health = 0;
            }
        }

        public void MoveTowards(int targetX, int targetY)
        {
            int dx = targetX - X;
            int dy = targetY - Y;
            if (dx != 0)
                X += dx / System.Math.Abs(dx);
            else if (dy != 0)
                Y += dy / System.Math.Abs(dy);
        }
    }
} 
TroopCosts.cs
namespace RattrapageProjet.Models
{
    public static class TroopCosts
    {
        public const int Archer = 30;
        public const int Barbarian = 40;
    }
} 
Wall.cs
namespace RattrapageProjet.Models
{
    public class Wall : Building
    {
        public Wall(int x, int y) : base(x, y, 20, "Wall")
        {
        }

        public override void OnInteract()
        {
        }
    }
} 
Game.cs
using System;
using RattrapageProjet.Models;
using System.Threading;


namespace RattrapageProjet
{
    public class Game
    {
        private Board board;
        private bool gameOver;
        private const int GridSize = 15;
        private Thread musicThread;
        

        public Game()
        {
            board = new Board();
            gameOver = false;
            board.Player.X = 5;
            board.Player.Y = 5;
            board.Player.Gold = 200;
            board.Player.Elixir = 100;
            
        }

        public void Run()
        {
            while (!gameOver)
            {
                DisplayGrid();
                PlayerAction();
                board.TroopActions();
                board.EnemyActions();
                board.RaiderAutoSpawn(0, 0);
                board.BombermanAutoSpawn(0, 0);
                gameOver = board.UpdateBuildingsAndCheckDefeat();
            }
            DisplayGrid();
            Console.WriteLine("D√©faite : le TownHall a √©t√© d√©truit.");
            Console.WriteLine();
            Console.WriteLine("====================================");
            Console.WriteLine();
            Console.WriteLine("         G  A  M  E   O  V  E  R   ");
            Console.WriteLine();
            Console.WriteLine("====================================");
        }

        private void DisplayGrid()
        {
            string[,] grid = new string[GridSize, GridSize];
            for (int y = 0; y < GridSize; y++)
                for (int x = 0; x < GridSize; x++)
                    grid[x, y] = "‚¨ú ";

            foreach (var b in board.Buildings)
            {
                string c = "‚¨ú ";
                if (b is TownHall) c = "üè∞ ";
                else if (b is GoldMine) c = "üí∞ ";
                else if (b is ElixirCollector) c = "üîÆ ";
                else if (b is Wall) c = "üß± ";
                else if (b is Barrack) c = "‚öîÔ∏è ";
                if (b.X >= 0 && b.X < GridSize && b.Y >= 0 && b.Y < GridSize)
                    grid[b.X, b.Y] = c;
            }
            foreach (var t in board.Troops)
            {
                string c = t is Archer ? "üéØ " : "ü™ì ";
                if (t.X >= 0 && t.X < GridSize && t.Y >= 0 && t.Y < GridSize)
                    grid[t.X, t.Y] = c;
            }
            foreach (var e in board.Enemies)
            {
                string c = e is Bomberman ? "üß® " : "üëæ ";
                if (e.X >= 0 && e.X < GridSize && e.Y >= 0 && e.Y < GridSize)
                    grid[e.X, e.Y] = c;
            }
            if (board.Player.X >= 0 && board.Player.X < GridSize && board.Player.Y >= 0 && board.Player.Y < GridSize)
                grid[board.Player.X, board.Player.Y] = "ü¶∏ ";

            Console.Clear();
            Console.OutputEncoding = System.Text.Encoding.UTF8;
            Console.Write("+");
            for (int x = 0; x < GridSize; x++) Console.Write("--");
            Console.WriteLine("+");
            for (int y = 0; y < GridSize; y++)
            {
                Console.Write("|");
                for (int x = 0; x < GridSize; x++)
                    Console.Write(grid[x, y]);
                Console.WriteLine("|");
            }
            Console.Write("+");
            for (int x = 0; x < GridSize; x++) Console.Write("--");
            Console.WriteLine("+");
            Console.WriteLine();
            Console.WriteLine("ü¶∏=Joueur üè∞=H√¥tel de Ville üí∞=Mine d'or üîÆ=Collecteur d'√©lixir üß±=Mur ‚öîÔ∏è=Caserne üéØ=Archer ü™ì=Barbare üëæ=Raider üß®=Bomberman ‚¨ú=Vide");
            Console.WriteLine($"Gold: {board.Player.Gold}   Elixir: {board.Player.Elixir}   TownHall: {GetTownHallHealth()}PV");
            Console.WriteLine("Actions : ZQSD=D√©placer, G=GoldMine, E=ElixirCollector, W=Wall, B=Barrack, C=Collecter, A=Archer, R=Barbarian, Q=Quitter");
            Console.WriteLine($"Co√ªts b√¢timents : GoldMine={BuildingCosts.GoldMine}G, ElixirCollector={BuildingCosts.ElixirCollector}G, Wall={BuildingCosts.Wall}G, Barrack={BuildingCosts.Barrack}G");
            Console.WriteLine($"Co√ªts troupes : Archer={TroopCosts.Archer}E, Barbarian={TroopCosts.Barbarian}E");
        }

        private int GetTownHallHealth()
        {
            foreach (var b in board.Buildings)
                if (b is TownHall) return b.Health;
            return 0;
        }

        private void PlayerAction()
        {
            var key = Console.ReadKey(true).Key;
            switch (key)
            {
                case ConsoleKey.Z:
                    board.Player.Move(0, -1);
                    break;
                case ConsoleKey.S:
                    board.Player.Move(0, 1);
                    break;
                case ConsoleKey.Q:
                    board.Player.Move(-1, 0);
                    break;
                case ConsoleKey.D:
                    board.Player.Move(1, 0);
                    break;
                case ConsoleKey.G:
                    board.BuildBuilding("GoldMine");
                    break;
                case ConsoleKey.E:
                    board.BuildBuilding("ElixirCollector");
                    break;
                case ConsoleKey.W:
                    board.BuildBuilding("Wall");
                    break;
                case ConsoleKey.B:
                    board.BuildBuilding("Barrack");
                    break;
                case ConsoleKey.C:
                    board.CollectResource();
                    break;
                case ConsoleKey.A:
                    board.TrainTroop("Archer");
                    break;
                case ConsoleKey.R:
                    board.TrainTroop("Barbarian");
                    break;
            }
        }
    }
} 
Program.cs 
using System;
using RattrapageProjet.Models;
using System.Threading;

namespace RattrapageProjet
{
    class Program
    {
        static void Main(string[] args)
        {
            var game = new Game();
            game.Run();
            Console.ReadKey();
        }
    }
}
